# 数组动态过滤

## 问题背景

搜索条件需要根据 type 动态配置。

## 解决思路

使用的搜索组件 ThFilterSearch 通过 filterOption 数组 v-for 进行搜索项配置，所以只需要根据条件控制某些项是否在 filterOption 即可：

```javascript
export default {
  computed: {
    filterOptions() {
      return [
        {
          id: "dataSourceName",
          header: "资源名称",
        },
        this.type != 3
          ? {
              id: "dataResourceType",
              header: "资源类型",
            }
          : null,
        this.type == 2
          ? {
              id: "shareType",
              header: "共享方式",
            }
          : null,
        {
          id: "createTime",
          header: "申请时间",
        },
      ].filter(Boolean);
    },
  },
};
```

这里实现筛选的关键在于 `[...Array].filter(Boolean)`这一段。每个 item 可以根据需要添加显示条件。如果不满足条件，这里就会是 null，在 filter() 方法中就会被过滤掉，最终输出的就都是已被过滤的数组。

## 场景延伸

> 有没有办法封装成一个方法？

如果上升到组件层次来看的话，这个逻辑其实在组件内部控制更加合理。基础的逻辑就是：给每一个 option 添加一个 `show` 或者类似的属性，在这个属性里定义一个方法，返回一个 Boolean 值，用来控制这个 option 是否显示。示例如下：

```vue
<script>
export default {
  data() {
    return {
      type: 1,
    };
  },
  computed: {
    filterOptions: [
      {
        // ...其他属性
        show() {
          // 也可以自己在这个方法里带其他 props 使用
          return this.type === 1;
        },
      },
    ],
  },
};
</script>
<template>
  <template v-for="(option, index) in filterOptions">
    <!-- 注意这里，v-for 不能和 v-if 在同一个标签使用。如果不介意，可以用 v-show -->
    <div v-if="option.show()" :key="index">{{ option }}</div>
  </template>
</template>
```

这样做的好处：

- 相较于在数组里直接写三元表达式，这样写在属性里，可读性更强，也更易于维护；
- 能够使用其他上下文。比如将渲染的某个 item，就可以直接带在 show() 的 prop 中进行判断。

这样做的坏处：

- option 多了一个实际不会使用的属性，可能对后续分析业务逻辑时产生影响；
- template 层要额外执行一次 `v-if`，增加了渲染压力；
- 实际传给 template 层的数据仍是完整的数组。
